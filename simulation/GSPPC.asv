%% === G-PPF 单图（保证扰动段自适应边界包络误差） ===
clear; close all; clc;

%% 1) 参数
Tp   = 2.0;  p = 0.8;  a = 0.20;  iota = 3.0;

% ★ 放松能力更强 + 反应更快  %%% CHANGED
Sigma_max  = 1.00;     % 由 0.55 -> 1.00（最大放宽至 100%）
k_d        = 2.50;     % 由 1.60 -> 2.50
tau_d_post = 0.15;     % 由 0.40 -> 0.15（更快）

% 前段饱和驱动
sigma0 = 1.00;  sigma_min = 0.60;  sigma_max = 1.60;
k_u = 1.00;     tau_u_pre = 0.15;

%% 2) 时间轴
T_end = 4.0;  N = 4800;  t0 = 1e-12;
t = linspace(t0, T_end, N)';  dt = t(2)-t(1);
idx_pre  = t <  Tp;    idx_post = t >= Tp;


%% 4) —— 普通性能函数 ρ_std(t)（用于对比）——
rho0   = 8*a;                         % 初始管径（可调小些以产生初值越界）
eps_Tp = 0.01;                        % t=Tp 时剩余比例 1%
lambda = -log(eps_Tp)/Tp;             % e^{-lambda*Tp} = eps_Tp
rho_std = (rho0 - a)*exp(-lambda*t) + a;  % 全程收敛到 a

%% 3) G-PPF 结构
b   = (t./Tp).^p;
s   = 1 - 3*b.^2 + 2*b.^3;
phi = -log(b);
g   = zeros(N,1);  g(idx_post) = 1 - exp( -iota*(t(idx_post)-Tp).^2 );

%% 4) 前段：饱和 → 残差 → sigma(t) 波动
u_max = 1.5; u_cmd = 2.1 + 0.9*sin(14*t);
DeltaU_pre = max(0, abs(u_cmd) - u_max);
taper = double(idx_pre) .* (1 - b.^2);
ru_pre = zeros(N,1);
for k=2:N
    ru_pre(k) = ru_pre(k-1) + dt*( -ru_pre(k-1) + DeltaU_pre(k).*taper(k) )/tau_u_pre;
end
sigma_adapt = min(max(sigma0 + k_u*ru_pre, sigma_min), sigma_max);

%% 5) 后段：单段正弦扰动 + 快速自适应  %%% CHANGED
% 单段窗（tanh 平滑开/关）
t_on=2.40; t_off=3.30; alpha=10;
seg = 0.5*(tanh(alpha*(t - t_on)) - tanh(alpha*(t - t_off))); % ∈(0,1)

% 扰动：单段正弦（只在窗内），幅值更大
A_sin = 1.60; f_sin = 2.0;
Distb_post = A_sin .* seg .* sin(2*pi*f_sin*(t - t_on)) .* idx_post;

% 低通得到 r_d（更快）
rd_post = zeros(N,1);
for k=2:N
    rd_post(k) = rd_post(k-1) + dt*( -rd_post(k-1) + Distb_post(k) )/tau_d_post;
end

% 误差用于 r_e（快速低通）  %%% CHANGED
E0 = 5.0*a;                                 % 初始误差更大
e  = E0*exp(-1.5*t);
e(idx_pre)  = e(idx_pre)  + 0.10*a*sin(22*t(idx_pre)) ;
e(idx_post) = e(idx_post) + 1.05*a .* seg(idx_post) .* sin(2*pi*f_sin*(t(idx_post)-t_on));

tau_e = 0.07;  k_e = 1.20;                   % 快速/较大权重
re_post = zeros(N,1);
for k=2:N
    re_post(k) = re_post(k-1) + dt*( -re_post(k-1) + abs(e(k))*idx_post(k) )/tau_e;
end

% 基础放松幅度 Σ0（含 r_d 与 r_e）  %%% CHANGED
Sigma0 = min(max(k_d*abs(rd_post) + k_e*re_post, 0), Sigma_max);

% 门控：扰动窗内直接全开（不再等待 g(t) 慢升）  %%% CHANGED
g_eff = max(g, seg);   % seg=1 的区间内 g_eff≈1

%% 6) 先计算自适应边界，再做“包络修正”（确保覆盖）  %%% CHANGED
rho_global = a + sigma0      .* phi .* s;     rho_global(idx_post) = a;

% 初始自适应边界
Sigma = Sigma0;
rho_adapt = a + sigma_adapt .* phi .* s;      % 先填 pre 段
rho_adapt(idx_post) = a.*(1 + g_eff(idx_post).*Sigma(idx_post));

% —— 包络修正：若 |e| > rho_adapt，则最小幅度抬高 Σ（受 Sigma_max 限制）
gap = abs(e) - rho_adapt;                 % 需要补的余量
need = max(gap, 0) ./ max(a*g_eff, 1e-9); % 转成需要增加的 Σ
add  = min(need, Sigma_max - Sigma);      % 受上限约束
Sigma = Sigma + add;                      % 修正后的 Σ
rho_adapt(idx_post) = a.*(1 + g_eff(idx_post).*Sigma(idx_post));  % 重新计算后段

%% 7) 绘图
col_global = [0.00 0.45 0.74];
col_adapt  = [0.85 0.33 0.10];
col_error  = [0.00 0.50 0.00];

figure('Color','w','Units','inches','Position',[1 1 7.2 3.2]);
ax = axes('Position',[0.12 0.20 0.84 0.72]); hold(ax,'on'); box(ax,'on');
set(ax,'FontName','Times New Roman','LineWidth',0.9,'TickDir','out',...
       'XMinorGrid','on','YMinorGrid','on','GridAlpha',0.16,'MinorGridAlpha',0.09);

% ±rho_global
plot(t,  rho_std, '--','LineWidth',1.5,'Color',col_error,'DisplayName','\pm\rho(t)(PPC)');
plot(t, -rho_std, '--','LineWidth',1.5,'Color',col_error,'HandleVisibility','off');

% ±rho_adapt
plot(t,  rho_adapt,  '-','LineWidth',1.5,'Color',col_global,'DisplayName','\pm\rho(t)(GS-PPC)');
plot(t, -rho_adapt,  '-','LineWidth',1.5,'Color',col_global,'HandleVisibility','off');

% e(t)
plot(t, e,  '-.','LineWidth',1.5,'Color',col_adapt,'DisplayName','e(t)');

xlim([0, 4]);  Ycap = 3;  ylim([-Ycap, Ycap]);

hTp = xline(Tp,'k--','T_p','LabelVerticalAlignment','bottom','LabelOrientation','horizontal','FontName','Times New Roman','FontSize',);
% set(hTp,'HandleVisibility','off');

xlabel('t (s)'); ylabel('error (rad)');
title('');
leg = legend('Location','northeast',Interpreter='latex'); 
set(leg,'Box','off');
grid off;
% %% 8) 图内箭头（与曲线错开）
x_inf = 0.13;
% % quiver(x_inf,  0.55*Ycap,  0,  0.35*Ycap, 0, 'Color',col_global,'LineWidth',1.2,'MaxHeadSize',0.9);
text(   x_inf+0.15, 0.82*Ycap, '+\infty','FontName','Times New Roman','FontSize',10,...
       'Color',col_global,'HorizontalAlignment','left','VerticalAlignment','bottom');
% % quiver(x_inf, -0.55*Ycap,  0, -0.35*Ycap, 0, 'Color',col_global,'LineWidth',1.2,'MaxHeadSize',0.9);
text(   x_inf+0.15,-0.82*Ycap, '-\infty','FontName','Times New Roman','FontSize',10,...
       'Color',col_global,'HorizontalAlignment','left','VerticalAlignment','top');

